---
description: Prefer getter methods over direct field access
globs: *.go
alwaysApply: false
---
# Go Standard: Prefer Getter Methods (Especially for Protobuf)

This rule encourages the use of getter methods over direct field access, particularly when working with structs generated from Protobuf definitions.

**The Standard:**

**Prefer using generated getter methods (e.g., `myProto.GetMyField()`) over direct field access (e.g., `myProto.MyField`) when such getters are available.** This is especially relevant for structs generated by the Protobuf compiler (`protoc-gen-go`).

**Rationale:**

*   **Encapsulation and Nil Safety:** Getters often provide a layer of abstraction. For Protobuf messages, getters automatically handle `nil` checks for pointer fields (like optional message fields or fields within a `oneof`), returning a zero value instead of causing a panic. This significantly improves robustness.
*   **Consistency:** Using getters consistently makes the code easier to read and maintain, aligning with common Go practices for Protobuf.
*   **Future-Proofing:** Relying on the getter method decouples the calling code from the exact internal representation of the field. If the underlying field changes in a backward-compatible way (e.g., how a default value is handled), code using the getter is less likely to break.
*   **Helper Logic:** Getters might potentially include minor logic (though less common in basic Protobuf getters beyond nil checks).

**Example (Protobuf):**

```protobuf
// -- Example.proto --
message UserProfile {
  optional string name = 1;
  optional int32 age = 2;
}
```

```go
// -- Go code --
import "path/to/gen/go/examplepb"

func processProfile(profile *examplepb.UserProfile) {
    // GOOD: Uses getter, safe even if profile or profile.Name is nil.
    name := profile.GetName()
    age := profile.GetAge() // Also handles potential nil receiver safely.

    // BAD: Direct access risks nil pointer dereference if profile is non-nil
    //      but profile.Name is nil (for optional fields).
    // nameDirect := *profile.Name // PANICS if profile.Name is nil!
    // ageDirect := *profile.Age   // PANICS if profile.Age is nil!

    fmt.Printf("Name: %s, Age: %d\n", name, age)
}
```

**Exceptions:**

*   **No Getter Available:** If a struct field does not have a corresponding getter method, direct access is necessary.
*   **Performance Critical Code:** In extremely rare, performance-critical sections where profiling has demonstrably shown the function call overhead of the getter to be a bottleneck, direct access *might* be considered cautiously. This should be well-documented and justified.
*   **Setting Values:** This rule applies to *reading* values. Setting struct fields typically involves direct assignment.
